@page "/editor"
@rendermode InteractiveServer
@using DecisionTreeShared.Models
@using RulesEditor.Services
@inject DecisionTreeService TreeService
@inject IJSRuntime JS

<PageTitle>Decision Tree Flow Builder</PageTitle>

<style>
    /* Full page flex layout confined to normal document flow so app layout nav remains visible */
    .flow-page { height: 100%; display: flex; flex-direction: column; padding: 0; overflow: hidden; background: #fff; position: relative; min-height: 0; }
    .flow-container { flex: 1 1 auto; padding: 20px; background: #f8f9fa; overflow: auto; position: relative; min-height: 0; }
    .flowchart-canvas { position: relative; min-height: 2500px; min-width: 5000px; padding: 80px; padding-left: 500px; }
    .flowchart-node { position: absolute; background: white; border: 2px solid #0d6efd; border-radius: 12px; padding: 15px 20px; min-width: 240px; max-width: 340px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); cursor: pointer; transition: all 0.2s; z-index: 1; }
    .flowchart-node:hover { box-shadow: 0 4px 12px rgba(0,0,0,0.25); transform: translateY(-2px); }
    .flowchart-node.start-node { border-color: #28a745; border-width: 3px; background: #f0fff4; }
    .flowchart-node.end-node { border-color: #dc3545; border-width: 2px; background: #fff5f5; border-radius: 20px; }
    .flowchart-node.choice-node { background: #e7f3ff; border-color: #0d6efd; border-radius: 8px; font-size: 14px; font-weight: 500; padding: 12px 16px; min-width: 200px; max-width: 250px; text-align: center; }
    .node-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .node-info { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .node-actions { display: flex; gap: 4px; }
    .node-prompt { font-size: 14px; line-height: 1.4; color: #212529; margin: 0; }
    .flowchart-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; }
    .add-node-button { position: absolute; border: 2px dashed #6c757d; background: #f8f9fa; padding: 10px 20px; border-radius: 8px; text-align: center; cursor: pointer; transition: all 0.2s; z-index: 1; }
    .add-node-button:hover { background: #e9ecef; border-color: #0d6efd; }
    .edit-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1050; }
    .edit-modal-content { background: white; border-radius: 8px; padding: 20px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto; }
</style>

<div class="flow-page">
    <div class="container-fluid flex-shrink-0">
        <div class="d-flex justify-content-between align-items-center p-3 bg-white border-bottom" style="gap:1rem;">
            <div>
                <h3 class="mb-0">Decision Tree Flow Builder</h3>
                <small class="text-muted">Follow the flow from top to bottom</small>
            </div>
            <div class="d-flex gap-2">
                <button class="btn btn-success" @onclick="SaveTree"><i class="bi bi-download"></i> Download Tree</button>
                <label class="btn btn-info mb-0"><i class="bi bi-upload"></i> Load <InputFile OnChange="LoadFile" class="d-none" accept=".json" /></label>
                <button class="btn btn-secondary" @onclick="NewTree"><i class="bi bi-file-earmark-plus"></i> New</button>
            </div>
        </div>
        @if (!string.IsNullOrEmpty(statusMessage))
        {
            <div class="alert @(isSuccess ? "alert-success" : "alert-danger") alert-dismissible fade show mx-3 my-2" role="alert">
                @statusMessage
                <button type="button" class="btn-close" aria-label="Close" @onclick="DismissStatus"></button>
            </div>
        }
    </div>

    <div class="flow-container">
        @if (string.IsNullOrEmpty(startNodeId) || !nodes.Any())
        {
            <div class="text-center py-5">
                <i class="bi bi-diagram-3" style="font-size: 4rem; color: #6c757d;"></i>
                <h4 class="mt-3">No Decision Tree Yet</h4>
                <p class="text-muted">Load a JSON file or add your first node to get started</p>
                <div class="d-flex gap-2 justify-content-center">
                    <button class="btn btn-primary btn-lg" @onclick="() => AddNodeAtPosition(null, null)"><i class="bi bi-plus-circle"></i> Add First Node</button>
                </div>
            </div>
        }
        else
        {
            <div class="flowchart-canvas">
                <svg class="flowchart-svg">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                            <polygon points="0 0, 10 3, 0 6" fill="#495057" />
                        </marker>
                    </defs>
                    @foreach (var d in connectorPaths)
                    {
                        <path d="@d" stroke="#495057" stroke-width="2" fill="none" marker-end="url(#arrowhead)" />
                    }
                </svg>
                @foreach (var pos in nodePositions.Values)
                {
                    if (pos.IsChoice)
                    {
                        <div class="flowchart-node choice-node" style="left:@(pos.X)px; top:@(pos.Y)px; width:@(pos.Width)px;">@pos.ChoiceLabel</div>
                    }
                    else
                    {
                        var node = nodes.FirstOrDefault(n => n.Id == pos.NodeId);
                        if (node != null)
                        {
                            <div class="flowchart-node @(node.Id == startNodeId ? "start-node" : null) @(node.Type == "End" ? "end-node" : null)" style="left:@(pos.X)px; top:@(pos.Y)px; width:@(pos.Width)px;" @onclick="() => EditNode(node)" data-node-id="@node.Id">
                                <div class="node-header">
                                    <div class="node-info">
                                        <span class="node-name" style="font-weight:600;font-size:12px;margin-right:8px;">@node.Id</span>
                                        <span class="badge bg-@GetNodeTypeBadge(node.Type)" style="font-size:10px;">@node.Type</span>
                                        @if (node.Id == startNodeId)
                                        {
                                            <span class="badge bg-success" style="font-size:10px;">START</span>
                                        }
                                    </div>
                                    <div class="node-actions">
                                        <button class="btn btn-sm btn-primary" style="padding:2px 6px;font-size:12px;" @onclick:stopPropagation="true" @onclick="() => EditNode(node)"><i class="bi bi-pencil"></i></button>
                                        <button class="btn btn-sm btn-danger" style="padding:2px 6px;font-size:12px;" @onclick:stopPropagation="true" @onclick="() => DeleteNode(node)"><i class="bi bi-trash"></i></button>
                                    </div>
                                </div>
                                @if (!string.Equals(node.Type, "End", StringComparison.OrdinalIgnoreCase))
                                {
                                    <div class="node-prompt">@node.Prompt</div>
                                }
                            </div>
                        }
                    }
                }
            </div>
        }
    </div>
</div>

@if (editingNode != null)
{
    <div class="edit-modal">
        <div class="edit-modal-content">
            <div class="d-flex justify-content-between align-items-center mb-3">
                <h5 class="mb-0">Edit Node</h5>
                <button class="btn-close" @onclick="CloseEditModal"></button>
            </div>

            <div class="mb-3">
                <label class="form-label"><strong>Node ID</strong></label>
                <input type="text" class="form-control" @bind="editingNode.Id" />
            </div>

            <div class="mb-3">
                <label class="form-label"><strong>Node Type</strong></label>
                <select class="form-select" @bind="editingNode.Type">
                    <option value="End">End - Terminal node</option>
                    <option value="SingleChoice">Single Choice - Multiple options</option>
                    <option value="Number">Number - Numeric evaluation</option>
                    <option value="Text">Text - Simple node with next connection</option>
                </select>
            </div>

            @if (editingNode.Type != "End")
            {
                <div class="mb-3">
                    <label class="form-label"><strong>Prompt / Message</strong></label>
                    <textarea class="form-control" rows="3" @bind="editingNode.Prompt"></textarea>
                </div>
            }

            @if (editingNode.Type == "SingleChoice")
            {
                <div class="mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <label class="form-label mb-0"><strong>Choices</strong></label>
                        <button class="btn btn-sm btn-primary" @onclick="AddChoice"><i class="bi bi-plus"></i> Add Choice</button>
                    </div>
                    @if (editingNode.Choices != null && editingNode.Choices.Any())
                    {
                        @for (int i = 0; i < editingNode.Choices.Count; i++)
                        {
                            var index = i; var choice = editingNode.Choices[index];
                            <div class="card mb-2">
                                <div class="card-body p-2">
                                    <div class="d-flex justify-content-between mb-2">
                                        <small class="text-muted">Choice @(index + 1)</small>
                                        <button class="btn btn-sm btn-danger" @onclick="() => RemoveChoice(index)"><i class="bi bi-x"></i></button>
                                    </div>
                                    <label class="form-label form-label-sm mb-1" style="font-size:0.85rem;"><strong>Key</strong> <span class="text-muted" title="Unique identifier used internally for this choice">ℹ️</span></label>
                                    <input type="text" class="form-control form-control-sm mb-2" placeholder="e.g., yes, no, option1" @bind="choice.Key" />
                                    <label class="form-label form-label-sm mb-1" style="font-size:0.85rem;"><strong>Label</strong> <span class="text-muted" title="User-friendly text shown for this choice">ℹ️</span></label>
                                    <input type="text" class="form-control form-control-sm mb-2" placeholder="e.g., Yes, No, First Option" @bind="choice.Label" />
                                    <label class="form-label form-label-sm mb-1" style="font-size:0.85rem;"><strong>Next Node</strong> <span class="text-muted" title="Which node to go to when this choice is selected">ℹ️</span></label>
                                    <select class="form-select form-select-sm" @bind="choice.NextNodeId">
                                        <option value="">-- Select Next Node --</option>
                                        @foreach (var node in nodes.Where(n => n.Id != editingNode.Id)) { <option value="@node.Id">@node.Id</option> }
                                        <option value="_new_">+ Create New Node</option>
                                    </select>
                                </div>
                            </div>
                        }
                    }
                </div>
            }
            @if (editingNode.Type == "Number")
            {
                <div class="mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <label class="form-label mb-0"><strong>Rules</strong></label>
                        <button class="btn btn-sm btn-primary" @onclick="AddRule"><i class="bi bi-plus"></i> Add Rule</button>
                    </div>
                    @if (editingNode.Rules != null && editingNode.Rules.Any())
                    {
                        @for (int i = 0; i < editingNode.Rules.Count; i++)
                        {
                            var index = i; var rule = editingNode.Rules[index];
                            <div class="card mb-2">
                                <div class="card-body p-2">
                                    <div class="d-flex justify-content-between mb-2">
                                        <small class="text-muted">Rule @(index + 1)</small>
                                        <button class="btn btn-sm btn-danger" @onclick="() => RemoveRule(index)"><i class="bi bi-x"></i></button>
                                    </div>
                                    <label class="form-label form-label-sm mb-1" style="font-size:0.85rem;"><strong>Operator</strong> <span class="text-muted" title="Comparison operation to apply">ℹ️</span></label>
                                    <select class="form-select form-select-sm mb-2" @bind="rule.Operator">
                                        <option value="LessThan">Less Than (&lt;)</option>
                                        <option value="LessThanOrEqual">Less Than or Equal (&lt;=)</option>
                                        <option value="GreaterThan">Greater Than (&gt;)</option>
                                        <option value="GreaterOrEqual">Greater Than or Equal (&gt;=)</option>
                                        <option value="Equal">Equal (=)</option>
                                    </select>
                                    <label class="form-label form-label-sm mb-1" style="font-size:0.85rem;"><strong>Value</strong> <span class="text-muted" title="Numeric threshold to compare against">ℹ️</span></label>
                                    <input type="number" class="form-control form-control-sm mb-2" placeholder="e.g., 100, 30, 0" @bind="rule.Value" />
                                    <label class="form-label form-label-sm mb-1" style="font-size:0.85rem;"><strong>Next Node</strong> <span class="text-muted" title="Which node to go to when this rule matches">ℹ️</span></label>
                                    <select class="form-select form-select-sm" @bind="rule.NextNodeId">
                                        <option value="">-- Select Next Node --</option>
                                        @foreach (var node in nodes.Where(n => n.Id != editingNode.Id)) { <option value="@node.Id">@node.Id</option> }
                                        <option value="_new_">+ Create New Node</option>
                                    </select>
                                </div>
                            </div>
                        }
                    }
                </div>
            }
            @if (editingNode.Type == "Text")
            {
                <div class="mb-3">
                    <label class="form-label"><strong>Next Node</strong></label>
                    <select class="form-select" @bind="editingNode.DefaultNextNodeId">
                        <option value="">-- Select Next Node --</option>
                        @foreach (var node in nodes.Where(n => n.Id != editingNode.Id)) { <option value="@node.Id">@node.Id</option> }
                        <option value="_new_">+ Create New Node</option>
                    </select>
                </div>
            }
            <div class="d-flex gap-2 justify-content-end">
                <button class="btn btn-secondary" @onclick="CloseEditModal">Close</button>
                <button class="btn btn-primary" @onclick="SaveEditedNode">Save Changes</button>
            </div>
        </div>
    </div>
}

@code {
    private string treeId = "my-decision-tree";
    private string treeVersion = "1.0.0";
    private string startNodeId = "";
    private List<DecisionNode> nodes = new();
    private DecisionNode? editingNode = null;
    private string statusMessage = "";
    private bool isSuccess = false;
    private HashSet<string> renderedNodes = new();
    private bool pendingScrollToStart = false;
    private IJSObjectReference? scrollModule;
    private IJSObjectReference? downloadModule;
    private int statusMessageVersion = 0;

    private class NodePosition { public string NodeId { get; set; } = string.Empty; public int X { get; set; } public int Y { get; set; } public int Width { get; set; } = 220; public int Height { get; set; } = 80; public bool IsChoice { get; set; } public string? ChoiceLabel { get; set; } }
    private Dictionary<string, NodePosition> nodePositions = new();
    private List<(NodePosition from, NodePosition to, string? label)> connections = new();
    private List<string> connectorPaths = new();
    private bool layoutCalculated = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            scrollModule = await JS.InvokeAsync<IJSObjectReference>("import", "./js/editorScroll.js");
            downloadModule = await JS.InvokeAsync<IJSObjectReference>("import", "./js/fileDownload.js");
        }
        if (pendingScrollToStart && !string.IsNullOrEmpty(startNodeId) && scrollModule != null)
        {
            pendingScrollToStart = false;
            try { await scrollModule.InvokeVoidAsync("scrollToNode", startNodeId); } catch { }
        }
    }

    private void CalculateFlowchartLayout()
    {
        nodePositions.Clear();
        connections.Clear();
        connectorPaths.Clear();
        if (string.IsNullOrEmpty(startNodeId)) return;

        int currentY = 100;
        var subtreeWidths = new Dictionary<string, int>();
        int totalTreeWidth = CalculateSubtreeWidths(startNodeId, new HashSet<string>(), subtreeWidths);
        int centerX = Math.Max(1200, (totalTreeWidth / 2) + 500);
        CalculateNodePositions(startNodeId, centerX, currentY, new HashSet<string>(), subtreeWidths);
        BuildConnectorPaths();
        layoutCalculated = true;
    }

    private void BuildConnectorPaths()
    {
        foreach (var (from, to, _) in connections)
        {
            int fromCenterX = from.X + (from.Width / 2);
            int fromBottom = from.Y + from.Height;
            int toCenterX = to.X + (to.Width / 2);
            int toTop = to.Y;
            int dropDownAmount = 30; int approachAmount = 30;
            int exitY = fromBottom + dropDownAmount; int approachY = toTop - approachAmount;
            string pathData;
            if (exitY < approachY)
            {
                int routingY = (exitY + approachY) / 2;
                pathData = $"M {fromCenterX} {fromBottom} L {fromCenterX} {routingY} L {toCenterX} {routingY} L {toCenterX} {toTop}";
            }
            else
            {
                int routingY = exitY + 20; int horizontalDistance = toCenterX - fromCenterX; int intermediateX = fromCenterX + (int)(horizontalDistance * 0.7);
                pathData = $"M {fromCenterX} {fromBottom} L {fromCenterX} {routingY} L {intermediateX} {routingY} L {intermediateX} {approachY} L {toCenterX} {approachY} L {toCenterX} {toTop}";
            }
            connectorPaths.Add(pathData);
        }
    }

    private int CalculateSubtreeWidths(string nodeId, HashSet<string> visited, Dictionary<string, int> subtreeWidths)
    {
        if (visited.Contains(nodeId) || string.IsNullOrEmpty(nodeId)) return 0;
        visited.Add(nodeId);
        var node = nodes.FirstOrDefault(n => n.Id == nodeId); if (node == null) return 400;
        var branches = GetNodeBranches(node);
        if (!branches.Any() || node.Type == "End") { subtreeWidths[nodeId] = 400; return 400; }
        int totalWidth = 0;
        foreach (var b in branches)
        {
            if (!string.IsNullOrEmpty(b.NextNodeId)) totalWidth += CalculateSubtreeWidths(b.NextNodeId, visited, subtreeWidths); else totalWidth += 400;
        }
        totalWidth += (branches.Count - 1) * 250;
        subtreeWidths[nodeId] = Math.Max(totalWidth, 400);
        return subtreeWidths[nodeId];
    }

    private int CalculateNodePositions(string nodeId, int x, int y, HashSet<string> visited, Dictionary<string, int> subtreeWidths)
    {
        if (visited.Contains(nodeId) || string.IsNullOrEmpty(nodeId)) return y;
        visited.Add(nodeId);
        var node = nodes.FirstOrDefault(n => n.Id == nodeId); if (node == null) return y;
        nodePositions[nodeId] = new NodePosition { NodeId = nodeId, X = x - 140, Y = y, Width = node.Type == "End" ? 300 : 280, Height = 95 };
        var branches = GetNodeBranches(node);
        if ((!branches.Any() && node.Type != "Text") || node.Type == "End") return y + 220;
        if (node.Type == "Text" && !string.IsNullOrEmpty(node.DefaultNextNodeId))
        {
            int textNextY = y + 220;
            if (!visited.Contains(node.DefaultNextNodeId))
            {
                int childBottomY = CalculateNodePositions(node.DefaultNextNodeId, x, textNextY, visited, subtreeWidths);
                if (nodePositions.ContainsKey(node.DefaultNextNodeId)) connections.Add((nodePositions[nodeId], nodePositions[node.DefaultNextNodeId], null));
                return childBottomY;
            }
            else { if (nodePositions.ContainsKey(node.DefaultNextNodeId)) connections.Add((nodePositions[nodeId], nodePositions[node.DefaultNextNodeId], null)); return textNextY + 100; }
        }
        int nextY = y + 320; int choiceY = y + 160; int nodeWidth = subtreeWidths.ContainsKey(nodeId) ? subtreeWidths[nodeId] : 400; int startX = x - (nodeWidth / 2); int currentX = startX; int maxBottomY = nextY;
        for (int i = 0; i < branches.Count; i++)
        {
            var b = branches[i]; int branchWidth = 400; if (!string.IsNullOrEmpty(b.NextNodeId) && subtreeWidths.ContainsKey(b.NextNodeId)) branchWidth = subtreeWidths[b.NextNodeId]; int branchCenterX = currentX + (branchWidth / 2);
            string choiceKey = $"{nodeId}_choice_{i}"; nodePositions[choiceKey] = new NodePosition { NodeId = choiceKey, X = branchCenterX - 110, Y = choiceY, Width = 220, Height = 75, IsChoice = true, ChoiceLabel = b.Label };
            connections.Add((nodePositions[nodeId], nodePositions[choiceKey], null));
            if (!string.IsNullOrEmpty(b.NextNodeId))
            {
                bool willPosition = !visited.Contains(b.NextNodeId);
                if (willPosition)
                { int childBottomY = CalculateNodePositions(b.NextNodeId, branchCenterX, nextY, visited, subtreeWidths); maxBottomY = Math.Max(maxBottomY, childBottomY); if (nodePositions.ContainsKey(b.NextNodeId)) connections.Add((nodePositions[choiceKey], nodePositions[b.NextNodeId], null)); }
                else { if (nodePositions.ContainsKey(b.NextNodeId)) connections.Add((nodePositions[choiceKey], nodePositions[b.NextNodeId], null)); }
            }
            currentX += branchWidth + 250;
        }
        return maxBottomY + 100;
    }

    private List<(string Label, string NextNodeId)> GetNodeBranches(DecisionNode node)
    {
        var list = new List<(string Label, string NextNodeId)>();
        if (node.Type == "SingleChoice" && node.Choices != null) foreach (var c in node.Choices) list.Add((c.Label, c.NextNodeId ?? ""));
        else if (node.Type == "Number" && node.Rules != null) foreach (var r in node.Rules) list.Add(($"{r.Operator} {r.Value}", r.NextNodeId ?? ""));
        return list;
    }

    private void EditNode(DecisionNode node) => editingNode = node;
    private void CloseEditModal() { editingNode = null; renderedNodes.Clear(); }

    private void SaveEditedNode()
    {
        if (editingNode != null)
        {
            if (editingNode.Type == "End") { editingNode.Prompt = string.Empty; editingNode.Choices = null; editingNode.Rules = null; editingNode.DefaultNextNodeId = null; }
            if (editingNode.Type == "SingleChoice" && editingNode.Choices != null)
            {
                foreach (var choice in editingNode.Choices.Where(c => c.NextNodeId == "_new_"))
                { var newNode = new DecisionNode { Id = $"node_{nodes.Count + 1}", Type = "End", Prompt = string.Empty }; nodes.Add(newNode); choice.NextNodeId = newNode.Id; }
            }
            if (editingNode.Type == "Number" && editingNode.Rules != null)
            {
                foreach (var rule in editingNode.Rules.Where(r => r.NextNodeId == "_new_"))
                { var newNode = new DecisionNode { Id = $"node_{nodes.Count + 1}", Type = "End", Prompt = string.Empty }; nodes.Add(newNode); rule.NextNodeId = newNode.Id; }
            }
            if (editingNode.Type == "Text" && editingNode.DefaultNextNodeId == "_new_")
            { var newNode = new DecisionNode { Id = $"node_{nodes.Count + 1}", Type = "End", Prompt = string.Empty }; nodes.Add(newNode); editingNode.DefaultNextNodeId = newNode.Id; }
        }
        editingNode = null; renderedNodes.Clear(); layoutCalculated = false; CalculateFlowchartLayout();
    }

    private void DeleteNode(DecisionNode node)
    {
        // Ensure edit modal is not shown after deletion
        if (editingNode == node) editingNode = null;
        nodes.Remove(node); if (startNodeId == node.Id) startNodeId = nodes.Any() ? nodes.First().Id : "";
        foreach (var n in nodes)
        {
            if (n.Choices != null) foreach (var ch in n.Choices.Where(c => c.NextNodeId == node.Id)) ch.NextNodeId = "";
            if (n.Rules != null) foreach (var rl in n.Rules.Where(r => r.NextNodeId == node.Id)) rl.NextNodeId = "";
        }
        renderedNodes.Clear(); layoutCalculated = false; CalculateFlowchartLayout(); if (!string.IsNullOrEmpty(startNodeId)) pendingScrollToStart = true;
    }

    private void AddNodeAtPosition(string? parentNodeId, string? branchLabel)
    {
        var newNode = new DecisionNode { Id = $"node_{nodes.Count + 1}", Type = "End", Prompt = string.Empty }; nodes.Add(newNode);
        if (parentNodeId != null)
        {
            var parent = nodes.FirstOrDefault(n => n.Id == parentNodeId);
            if (parent != null)
            {
                if (parent.Type == "SingleChoice" && parent.Choices != null)
                {
                    var ch = parent.Choices.FirstOrDefault(c => c.Label == branchLabel);
                    if (ch != null) ch.NextNodeId = newNode.Id;
                }
                else if (parent.Type == "Number" && parent.Rules != null)
                {
                    var rl = parent.Rules.FirstOrDefault(r => $"{r.Operator} {r.Value}" == branchLabel);
                    if (rl != null) rl.NextNodeId = newNode.Id;
                }
            }
        }
        else if (string.IsNullOrEmpty(startNodeId)) startNodeId = newNode.Id;
        editingNode = newNode; renderedNodes.Clear(); layoutCalculated = false; CalculateFlowchartLayout(); if (!string.IsNullOrEmpty(startNodeId)) pendingScrollToStart = true;
    }

    private void AddChoice() { if (editingNode != null) { editingNode.Choices ??= new List<Choice>(); editingNode.Choices.Add(new Choice { Key = $"choice{editingNode.Choices.Count + 1}", Label = "New Choice", NextNodeId = "" }); } }
    private void RemoveChoice(int i) { if (editingNode?.Choices != null && i < editingNode.Choices.Count) { editingNode.Choices.RemoveAt(i); layoutCalculated = false; CalculateFlowchartLayout(); } }
    private void AddRule() { if (editingNode != null) { editingNode.Rules ??= new List<Rule>(); editingNode.Rules.Add(new Rule { Operator = "LessThan", Value = "0", NextNodeId = "" }); } }
    private void RemoveRule(int i) { if (editingNode?.Rules != null && i < editingNode.Rules.Count) { editingNode.Rules.RemoveAt(i); layoutCalculated = false; CalculateFlowchartLayout(); } }

    private void NewTree() { treeId = "new-tree"; treeVersion = "1.0.0"; startNodeId = ""; nodes.Clear(); editingNode = null; statusMessage = string.Empty; renderedNodes.Clear(); layoutCalculated = false; CalculateFlowchartLayout(); }

    private async Task LoadFile(InputFileChangeEventArgs e)
    {
        try
        {
            var file = e.File; if (file == null) return; using var stream = file.OpenReadStream(1024 * 1024); using var reader = new StreamReader(stream); var json = await reader.ReadToEndAsync();
            var result = TreeService.LoadFromJson(json);
            if (result.Success && result.Tree != null)
            {
                treeId = result.Tree.Id; treeVersion = result.Tree.Version; startNodeId = result.Tree.StartNodeId; nodes = result.Tree.Nodes.Values.ToList();
                foreach (var n in nodes.Where(n => string.Equals(n.Type, "End", StringComparison.OrdinalIgnoreCase))) n.Prompt = string.Empty;
                editingNode = null; ShowStatus("Tree loaded successfully!", true); renderedNodes.Clear(); layoutCalculated = false; CalculateFlowchartLayout(); if (!string.IsNullOrEmpty(startNodeId)) pendingScrollToStart = true;
            }
            else ShowStatus($"Error loading tree: {result.ErrorMessage}", false);
        }
        catch (Exception ex) { ShowStatus($"Error loading file: {ex.Message}", false); }
    }

    private async Task SaveTree()
    {
        try
        {
            foreach (var n in nodes.Where(n => string.Equals(n.Type, "End", StringComparison.OrdinalIgnoreCase))) n.Prompt = string.Empty;
            var tree = new DecisionTree { Id = treeId, Version = treeVersion, StartNodeId = startNodeId, Nodes = nodes.ToDictionary(n => n.Id, n => n) };
            var json = TreeService.SerializeToJson(tree); var result = TreeService.LoadFromJson(json);
            if (result.Success)
            {
                if (downloadModule != null)
                { var filename = $"{treeId}.json"; var success = await downloadModule.InvokeAsync<bool>("downloadJsonFile", filename, json); ShowStatus(success ? $"✓ Tree downloaded as {filename}" : "Error downloading file", success); }
                else ShowStatus("Download module not loaded", false);
            }
            else ShowStatus($"Validation failed: {result.ErrorMessage}", false);
        }
        catch (Exception ex) { ShowStatus($"Error: {ex.Message}", false); }
    }

    private string GetNodeTypeBadge(string type) => type switch { "End" => "danger", "SingleChoice" => "primary", "Number" => "warning", "Text" => "info", _ => "secondary" };

    private void ShowStatus(string message, bool success)
    { statusMessage = message; isSuccess = success; var version = ++statusMessageVersion; _ = Task.Run(async () => { await Task.Delay(5000); if (version == statusMessageVersion) { try { await InvokeAsync(() => { statusMessage = string.Empty; StateHasChanged(); }); } catch { } } }); StateHasChanged(); }
    private void DismissStatus() { statusMessageVersion++; statusMessage = string.Empty; }
}
