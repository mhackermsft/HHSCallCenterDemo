@page "/editor"
@rendermode InteractiveServer
@using DecisionTreeShared.Models
@using RulesEditor.Services
@inject DecisionTreeService TreeService

<PageTitle>Decision Tree Flow Builder</PageTitle>

<style>
    .flow-container {
        padding: 20px;
        background: #f8f9fa;
        min-height: calc(100vh - 100px);
        overflow: auto;
        position: relative;
    }
    
    .flowchart-canvas {
        position: relative;
        min-height: 2500px;
        min-width: 5000px;
        padding: 80px;
        padding-left: 500px; /* Extra space on left to avoid nav menu overlap */
    }
    
    .flowchart-node {
        position: absolute;
        background: white;
        border: 2px solid #0d6efd;
        border-radius: 12px;
        padding: 15px 20px;
        min-width: 240px;
        max-width: 340px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        cursor: pointer;
        transition: all 0.2s;
    }
    
    .flowchart-node:hover {
        box-shadow: 0 4px 12px rgba(0,0,0,0.25);
        transform: translateY(-2px);
    }
    
    .flowchart-node.start-node {
        border-color: #28a745;
        border-width: 3px;
        background: #f0fff4;
    }
    
    .flowchart-node.end-node {
        border-color: #dc3545;
        border-width: 2px;
        background: #fff5f5;
        border-radius: 20px;
    }
    
    .flowchart-node.choice-node {
        background: #e7f3ff;
        border-color: #0d6efd;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        padding: 12px 16px;
        min-width: 200px;
        max-width: 250px;
        text-align: center;
    }
    
    .node-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
    }
    
    .node-info {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
    }
    
    .node-actions {
        display: flex;
        gap: 4px;
    }
    
    .node-prompt {
        font-size: 14px;
        line-height: 1.4;
        color: #212529;
        margin: 0;
    }
    
    .flowchart-svg {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 0;
    }
    
    .flowchart-node {
        z-index: 1;
    }
    
    .add-node-button {
        position: absolute;
        border: 2px dashed #6c757d;
        background: #f8f9fa;
        padding: 10px 20px;
        border-radius: 8px;
        text-align: center;
        cursor: pointer;
        transition: all 0.2s;
        z-index: 1;
    }
    
    .add-node-button:hover {
        background: #e9ecef;
        border-color: #0d6efd;
    }
    
    .edit-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1050;
    }
    
    .edit-modal-content {
        background: white;
        border-radius: 8px;
        padding: 20px;
        max-width: 600px;
        width: 90%;
        max-height: 90vh;
        overflow-y: auto;
    }
</style>

<div class="container-fluid">
    <div class="d-flex justify-content-between align-items-center mb-3 p-3 bg-white border-bottom">
        <div>
            <h3 class="mb-0">Decision Tree Flow Builder</h3>
            <small class="text-muted">Follow the flow from top to bottom</small>
        </div>
        <div class="d-flex gap-2">
            <button class="btn btn-success" @onclick="SaveTree">
                <i class="bi bi-save"></i> Save Tree
            </button>
            <label class="btn btn-info">
                <i class="bi bi-upload"></i> Load
                <InputFile OnChange="LoadFile" class="d-none" accept=".json" />
            </label>
            <button class="btn btn-secondary" @onclick="NewTree">
                <i class="bi bi-file-earmark-plus"></i> New
            </button>
        </div>
    </div>

    @if (!string.IsNullOrEmpty(statusMessage))
    {
        <div class="alert @(isSuccess ? "alert-success" : "alert-danger") mx-3" role="alert">
            @statusMessage
        </div>
    }

    <div class="flow-container">
        @if (string.IsNullOrEmpty(startNodeId) || !nodes.Any())
        {
            <div class="text-center py-5">
                <i class="bi bi-diagram-3" style="font-size: 4rem; color: #6c757d;"></i>
                <h4 class="mt-3">No Decision Tree Yet</h4>
                <p class="text-muted">Click "New Tree" or add your first node to get started</p>
                <button class="btn btn-primary btn-lg" @onclick="() => AddNodeAtPosition(null, null)">
                    <i class="bi bi-plus-circle"></i> Add First Node
                </button>
            </div>
        }
        else
        {
            <div class="flowchart-canvas">
                <svg class="flowchart-svg">
                    @RenderConnectors()
                </svg>
                @RenderFlowchart()
            </div>
        }
    </div>
</div>

@if (editingNode != null)
{
    <div class="edit-modal" @onclick="CloseEditModal">
        <div class="edit-modal-content" @onclick:stopPropagation="true">
            <div class="d-flex justify-content-between align-items-center mb-3">
                <h5 class="mb-0">Edit Node</h5>
                <button class="btn-close" @onclick="CloseEditModal"></button>
            </div>

            <div class="mb-3">
                <label class="form-label"><strong>Node ID</strong></label>
                <input type="text" class="form-control" @bind="editingNode.Id" />
            </div>

            <div class="mb-3">
                <label class="form-label"><strong>Node Type</strong></label>
                <select class="form-select" @bind="editingNode.Type">
                    <option value="End">End - Terminal node</option>
                    <option value="SingleChoice">Single Choice - Multiple options</option>
                    <option value="Number">Number - Numeric evaluation</option>
                </select>
            </div>

            <div class="mb-3">
                <label class="form-label"><strong>Prompt / Message</strong></label>
                <textarea class="form-control" rows="3" @bind="editingNode.Prompt"></textarea>
            </div>

            @if (editingNode.Type == "SingleChoice")
            {
                <div class="mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <label class="form-label mb-0"><strong>Choices</strong></label>
                        <button class="btn btn-sm btn-primary" @onclick="AddChoice">
                            <i class="bi bi-plus"></i> Add Choice
                        </button>
                    </div>
                    
                    @if (editingNode.Choices != null && editingNode.Choices.Any())
                    {
                        @for (int i = 0; i < editingNode.Choices.Count; i++)
                        {
                            var index = i;
                            var choice = editingNode.Choices[index];
                            <div class="card mb-2">
                                <div class="card-body p-2">
                                    <div class="d-flex justify-content-between mb-2">
                                        <small class="text-muted">Choice @(index + 1)</small>
                                        <button class="btn btn-sm btn-danger" @onclick="() => RemoveChoice(index)">
                                            <i class="bi bi-x"></i>
                                        </button>
                                    </div>
                                    <input type="text" class="form-control form-control-sm mb-1" placeholder="Key" @bind="choice.Key" />
                                    <input type="text" class="form-control form-control-sm mb-1" placeholder="Label" @bind="choice.Label" />
                                    <select class="form-select form-select-sm" @bind="choice.NextNodeId">
                                        <option value="">-- Select Next Node --</option>
                                        @foreach (var node in nodes.Where(n => n.Id != editingNode.Id))
                                        {
                                            <option value="@node.Id">@node.Id</option>
                                        }
                                        <option value="_new_">+ Create New Node</option>
                                    </select>
                                </div>
                            </div>
                        }
                    }
                </div>
            }

            @if (editingNode.Type == "Number")
            {
                <div class="mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <label class="form-label mb-0"><strong>Rules</strong></label>
                        <button class="btn btn-sm btn-primary" @onclick="AddRule">
                            <i class="bi bi-plus"></i> Add Rule
                        </button>
                    </div>
                    
                    @if (editingNode.Rules != null && editingNode.Rules.Any())
                    {
                        @for (int i = 0; i < editingNode.Rules.Count; i++)
                        {
                            var index = i;
                            var rule = editingNode.Rules[index];
                            <div class="card mb-2">
                                <div class="card-body p-2">
                                    <div class="d-flex justify-content-between mb-2">
                                        <small class="text-muted">Rule @(index + 1)</small>
                                        <button class="btn btn-sm btn-danger" @onclick="() => RemoveRule(index)">
                                            <i class="bi bi-x"></i>
                                        </button>
                                    </div>
                                    <select class="form-select form-select-sm mb-1" @bind="rule.Operator">
                                        <option value="LessThan">Less Than (&lt;)</option>
                                        <option value="LessThanOrEqual">Less Than or Equal (&lt;=)</option>
                                        <option value="GreaterThan">Greater Than (&gt;)</option>
                                        <option value="GreaterOrEqual">Greater Than or Equal (&gt;=)</option>
                                        <option value="Equal">Equal (=)</option>
                                    </select>
                                    <input type="number" class="form-control form-control-sm mb-1" placeholder="Value" @bind="rule.Value" />
                                    <select class="form-select form-select-sm" @bind="rule.NextNodeId">
                                        <option value="">-- Select Next Node --</option>
                                        @foreach (var node in nodes.Where(n => n.Id != editingNode.Id))
                                        {
                                            <option value="@node.Id">@node.Id</option>
                                        }
                                        <option value="_new_">+ Create New Node</option>
                                    </select>
                                </div>
                            </div>
                        }
                    }
                </div>
            }

            <div class="d-flex gap-2 justify-content-end">
                <button class="btn btn-secondary" @onclick="CloseEditModal">Close</button>
                <button class="btn btn-primary" @onclick="SaveEditedNode">Save Changes</button>
            </div>
        </div>
    </div>
}

@code {
    private string treeId = "my-decision-tree";
    private string treeVersion = "1.0.0";
    private string startNodeId = "";
    private List<DecisionNode> nodes = new();
    private DecisionNode? editingNode = null;
    private string statusMessage = "";
    private bool isSuccess = false;
    private HashSet<string> renderedNodes = new();

    protected override void OnInitialized()
    {
        LoadExampleTree();
    }
    
    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender || !layoutCalculated)
        {
            CalculateFlowchartLayout();
            StateHasChanged();
        }
    }

    private class NodePosition
    {
        public string NodeId { get; set; } = string.Empty;
        public int X { get; set; }
        public int Y { get; set; }
        public int Width { get; set; } = 220;
        public int Height { get; set; } = 80;
        public bool IsChoice { get; set; }
        public string? ChoiceLabel { get; set; }
    }
    
    private Dictionary<string, NodePosition> nodePositions = new();
    private List<(NodePosition from, NodePosition to, string? label)> connections = new();
    private bool layoutCalculated = false;
    
    private void CalculateFlowchartLayout()
    {
        nodePositions.Clear();
        connections.Clear();
        
        if (string.IsNullOrEmpty(startNodeId)) return;
        
        int currentY = 100;
        
        // First pass: calculate tree width needed
        var subtreeWidths = new Dictionary<string, int>();
        int totalTreeWidth = CalculateSubtreeWidths(startNodeId, new HashSet<string>(), subtreeWidths);
        
        // Position start node centered based on total tree width
        int centerX = Math.Max(1200, (totalTreeWidth / 2) + 500); // Ensure enough left margin
        
        // Second pass: position nodes with proper spacing
        CalculateNodePositions(startNodeId, centerX, currentY, new HashSet<string>(), subtreeWidths);
        
        layoutCalculated = true;
    }
    
    private int CalculateSubtreeWidths(string nodeId, HashSet<string> visited, Dictionary<string, int> subtreeWidths)
    {
        if (visited.Contains(nodeId) || string.IsNullOrEmpty(nodeId))
            return 0;
            
        visited.Add(nodeId);
        
        var node = nodes.FirstOrDefault(n => n.Id == nodeId);
        if (node == null) return 400; // Default width for missing nodes
        
        var branches = GetNodeBranches(node);
        if (!branches.Any() || node.Type == "End")
        {
            subtreeWidths[nodeId] = 400; // Width for a single node with good margin
            return 400;
        }
        
        // Calculate total width needed for all child branches
        int totalWidth = 0;
        foreach (var branch in branches)
        {
            if (!string.IsNullOrEmpty(branch.NextNodeId))
            {
                int childWidth = CalculateSubtreeWidths(branch.NextNodeId, visited, subtreeWidths);
                totalWidth += childWidth;
            }
            else
            {
                totalWidth += 400; // Width for branch without next node
            }
        }
        
        // Add generous spacing between branches to prevent overlap
        totalWidth += (branches.Count - 1) * 250; // 250px spacing between branches
        
        subtreeWidths[nodeId] = Math.Max(totalWidth, 400);
        return subtreeWidths[nodeId];
    }
    
    private int CalculateNodePositions(string nodeId, int x, int y, HashSet<string> visited, Dictionary<string, int> subtreeWidths)
    {
        if (visited.Contains(nodeId) || string.IsNullOrEmpty(nodeId))
            return y;
            
        visited.Add(nodeId);
        
        var node = nodes.FirstOrDefault(n => n.Id == nodeId);
        if (node == null) return y;
        
        // Position the current node
        nodePositions[nodeId] = new NodePosition
        {
            NodeId = nodeId,
            X = x - 140, // Center the node (280px wide / 2)
            Y = y,
            Width = node.Type == "End" ? 300 : 280,
            Height = 95
        };
        
        var branches = GetNodeBranches(node);
        if (!branches.Any() || node.Type == "End")
            return y + 220;
        
        int nextY = y + 320; // Increased vertical space for clear arrow visibility
        int choiceY = y + 160; // Space for choice boxes
        
        // Calculate positions for branches based on subtree widths
        int nodeWidth = subtreeWidths.ContainsKey(nodeId) ? subtreeWidths[nodeId] : 400;
        int startX = x - (nodeWidth / 2);
        int currentX = startX;
        
        int maxBottomY = nextY;
        
        for (int i = 0; i < branches.Count; i++)
        {
            var branch = branches[i];
            
            // Get width for this branch's subtree
            int branchWidth = 400;
            if (!string.IsNullOrEmpty(branch.NextNodeId) && subtreeWidths.ContainsKey(branch.NextNodeId))
            {
                branchWidth = subtreeWidths[branch.NextNodeId];
            }
            
            int branchCenterX = currentX + (branchWidth / 2);
            
            // Position choice box
            string choiceKey = $"{nodeId}_choice_{i}";
            nodePositions[choiceKey] = new NodePosition
            {
                NodeId = choiceKey,
                X = branchCenterX - 110, // Center the 220px wide choice box
                Y = choiceY,
                Width = 220,
                Height = 75,
                IsChoice = true,
                ChoiceLabel = branch.Label
            };
            
            // Add connection from node to choice
            connections.Add((nodePositions[nodeId], nodePositions[choiceKey], null));
            
            // Position next node if it exists
            if (!string.IsNullOrEmpty(branch.NextNodeId))
            {
                int childBottomY = CalculateNodePositions(branch.NextNodeId, branchCenterX, nextY, visited, subtreeWidths);
                maxBottomY = Math.Max(maxBottomY, childBottomY);
                
                // Add connection from choice to next node
                if (nodePositions.ContainsKey(branch.NextNodeId))
                {
                    connections.Add((nodePositions[choiceKey], nodePositions[branch.NextNodeId], null));
                }
            }
            
            // Move to next branch position with generous spacing
            currentX += branchWidth + 250; // Add spacing between branches
        }
        
        return maxBottomY + 100; // Add extra spacing at bottom
    }
    
    private RenderFragment RenderFlowchart() => builder =>
    {
        if (!layoutCalculated)
        {
            CalculateFlowchartLayout();
        }
        
        foreach (var pos in nodePositions.Values)
        {
            if (pos.IsChoice)
            {
                // Render choice box
                builder.OpenElement(0, "div");
                builder.AddAttribute(1, "class", "flowchart-node choice-node");
                builder.AddAttribute(2, "style", $"left: {pos.X}px; top: {pos.Y}px; width: {pos.Width}px;");
                builder.AddContent(3, pos.ChoiceLabel);
                builder.CloseElement();
            }
            else
            {
                // Render node
                builder.AddContent(4, RenderFlowchartNode(pos));
            }
        }
    };
    
    private RenderFragment RenderFlowchartNode(NodePosition pos) => builder =>
    {
        var node = nodes.FirstOrDefault(n => n.Id == pos.NodeId);
        if (node == null) return;
        
        builder.OpenElement(0, "div");
        builder.AddAttribute(1, "class", $"flowchart-node {(node.Id == startNodeId ? "start-node" : "")} {(node.Type == "End" ? "end-node" : "")}");
        builder.AddAttribute(2, "style", $"left: {pos.X}px; top: {pos.Y}px; width: {pos.Width}px;");
        builder.AddAttribute(3, "onclick", EventCallback.Factory.Create(this, () => EditNode(node)));
        
        // Node header
        builder.OpenElement(4, "div");
        builder.AddAttribute(5, "class", "node-header");
        
        builder.OpenElement(6, "div");
        builder.AddAttribute(7, "class", "node-info");
        builder.OpenElement(8, "span");
        builder.AddAttribute(9, "class", $"badge bg-{GetNodeTypeBadge(node.Type)}");
        builder.AddAttribute(10, "style", "font-size: 10px;");
        builder.AddContent(11, node.Type);
        builder.CloseElement();
        if (node.Id == startNodeId)
        {
            builder.OpenElement(12, "span");
            builder.AddAttribute(13, "class", "badge bg-success");
            builder.AddAttribute(14, "style", "font-size: 10px;");
            builder.AddContent(15, "START");
            builder.CloseElement();
        }
        builder.CloseElement();
        
        // Actions
        builder.OpenElement(16, "div");
        builder.AddAttribute(17, "class", "node-actions");
        builder.OpenElement(18, "button");
        builder.AddAttribute(19, "class", "btn btn-sm btn-primary");
        builder.AddAttribute(20, "onclick", EventCallback.Factory.Create(this, () => EditNode(node)));
        builder.AddAttribute(21, "style", "padding: 2px 6px; font-size: 12px;");
        builder.OpenElement(22, "i");
        builder.AddAttribute(23, "class", "bi bi-pencil");
        builder.CloseElement();
        builder.CloseElement();
        builder.OpenElement(24, "button");
        builder.AddAttribute(25, "class", "btn btn-sm btn-danger");
        builder.AddAttribute(26, "onclick", EventCallback.Factory.Create(this, () => DeleteNode(node)));
        builder.AddAttribute(27, "style", "padding: 2px 6px; font-size: 12px;");
        builder.OpenElement(28, "i");
        builder.AddAttribute(29, "class", "bi bi-trash");
        builder.CloseElement();
        builder.CloseElement();
        builder.CloseElement();
        
        builder.CloseElement(); // node-header
        
        // Node prompt
        builder.OpenElement(30, "div");
        builder.AddAttribute(31, "class", "node-prompt");
        builder.AddContent(32, node.Prompt);
        builder.CloseElement();
        
        builder.CloseElement(); // flowchart-node
    };
    
    private RenderFragment RenderConnectors() => builder =>
    {
        // Define arrowhead marker first
        builder.OpenElement(0, "defs");
        builder.OpenElement(1, "marker");
        builder.AddAttribute(2, "id", "arrowhead");
        builder.AddAttribute(3, "markerWidth", "10");
        builder.AddAttribute(4, "markerHeight", "10");
        builder.AddAttribute(5, "refX", "9");
        builder.AddAttribute(6, "refY", "3");
        builder.AddAttribute(7, "orient", "auto");
        builder.OpenElement(8, "polygon");
        builder.AddAttribute(9, "points", "0 0, 10 3, 0 6");
        builder.AddAttribute(10, "fill", "#495057");
        builder.CloseElement();
        builder.CloseElement();
        builder.CloseElement();
        
        foreach (var (from, to, label) in connections)
        {
            // Calculate connection points
            int fromCenterX = from.X + (from.Width / 2);
            int fromBottom = from.Y + from.Height;
            int toCenterX = to.X + (to.Width / 2);
            int toTop = to.Y;
            
            // Draw straight or angled line
            if (Math.Abs(fromCenterX - toCenterX) < 10)
            {
                // Straight line
                builder.OpenElement(11, "line");
                builder.AddAttribute(12, "x1", fromCenterX);
                builder.AddAttribute(13, "y1", fromBottom);
                builder.AddAttribute(14, "x2", toCenterX);
                builder.AddAttribute(15, "y2", toTop);
                builder.AddAttribute(16, "stroke", "#495057");
                builder.AddAttribute(17, "stroke-width", "2");
                builder.AddAttribute(18, "marker-end", "url(#arrowhead)");
                builder.CloseElement();
            }
            else
            {
                // Angled line with path
                int midY = (fromBottom + toTop) / 2;
                string path = $"M {fromCenterX} {fromBottom} L {fromCenterX} {midY} L {toCenterX} {midY} L {toCenterX} {toTop}";
                
                builder.OpenElement(19, "path");
                builder.AddAttribute(20, "d", path);
                builder.AddAttribute(21, "stroke", "#495057");
                builder.AddAttribute(22, "stroke-width", "2");
                builder.AddAttribute(23, "fill", "none");
                builder.AddAttribute(24, "marker-end", "url(#arrowhead)");
                builder.CloseElement();
            }
        }
    };

    private List<(string Label, string NextNodeId)> GetNodeBranches(DecisionNode node)
    {
        var branches = new List<(string Label, string NextNodeId)>();
        
        if (node.Type == "SingleChoice" && node.Choices != null)
        {
            foreach (var choice in node.Choices)
            {
                branches.Add((choice.Label, choice.NextNodeId ?? ""));
            }
        }
        else if (node.Type == "Number" && node.Rules != null)
        {
            foreach (var rule in node.Rules)
            {
                branches.Add(($"{rule.Operator} {rule.Value}", rule.NextNodeId ?? ""));
            }
        }
        
        return branches;
    }

    private void LoadExampleTree()
    {
        treeId = "essence-triage-demo";
        treeVersion = "1.0.0";
        startNodeId = "q_greeting";
        
        nodes = new List<DecisionNode>
        {
            new DecisionNode
            {
                Id = "q_greeting",
                Type = "SingleChoice",
                Prompt = "Welcome to Essence of Oregon support. What brings you here today?",
                Choices = new List<Choice>
                {
                    new Choice { Key = "cancel", Label = "I want to cancel my subscription", NextNodeId = "q_reason" },
                    new Choice { Key = "other", Label = "Something else", NextNodeId = "end_other" }
                }
            },
            new DecisionNode
            {
                Id = "q_reason",
                Type = "SingleChoice",
                Prompt = "What is the main reason for canceling?",
                Choices = new List<Choice>
                {
                    new Choice { Key = "affordability", Label = "It's too expensive", NextNodeId = "q_usage" },
                    new Choice { Key = "dont_like", Label = "I didn't like the product", NextNodeId = "end_cancelled" },
                    new Choice { Key = "other", Label = "Other reason", NextNodeId = "end_escalate" }
                }
            },
            new DecisionNode
            {
                Id = "q_usage",
                Type = "SingleChoice",
                Prompt = "Have you had a chance to use the product enough to see results?",
                Choices = new List<Choice>
                {
                    new Choice { Key = "yes", Label = "Yes", NextNodeId = "q_discount40" },
                    new Choice { Key = "no", Label = "Not really", NextNodeId = "q_extend_offer" }
                }
            },
            new DecisionNode
            {
                Id = "q_extend_offer",
                Type = "SingleChoice",
                Prompt = "We can extend your free trial by 15 days at no charge so you can evaluate further. Would you like to accept the extension?",
                Choices = new List<Choice>
                {
                    new Choice { Key = "accept", Label = "Yes, extend my free trial", NextNodeId = "end_extended" },
                    new Choice { Key = "decline", Label = "No, I'd still like to cancel", NextNodeId = "q_discount40" }
                }
            },
            new DecisionNode
            {
                Id = "q_discount40",
                Type = "SingleChoice",
                Prompt = "We can offer a lifetime 40% employee discount. Keep the subscription for $50.28/month (from $83.80)?",
                Choices = new List<Choice>
                {
                    new Choice { Key = "accept", Label = "Accept $50.28/month", NextNodeId = "end_keep40" },
                    new Choice { Key = "decline", Label = "Still can't afford it", NextNodeId = "q_affordable_price" }
                }
            },
            new DecisionNode
            {
                Id = "q_affordable_price",
                Type = "Number",
                Prompt = "What monthly price (USD) would make it affordable for you?",
                Rules = new List<Rule>
                {
                    new Rule { Operator = "LessThanOrEqual", Value = "20", NextNodeId = "end_supervisor_80" },
                    new Rule { Operator = "GreaterThan", Value = "20", NextNodeId = "end_cancelled" }
                }
            },
            new DecisionNode
            {
                Id = "end_extended",
                Type = "End",
                Prompt = "Your free trial has been extended by 15 days. Please evaluate and contact us before it ends if you still wish to cancel."
            },
            new DecisionNode
            {
                Id = "end_keep40",
                Type = "End",
                Prompt = "Great! Your subscription will continue at the 40% discounted rate of $50.28/month."
            },
            new DecisionNode
            {
                Id = "end_supervisor_80",
                Type = "End",
                Prompt = "Approved by supervisor: lifetime 80% discount. Your monthly price will be $16.76."
            },
            new DecisionNode
            {
                Id = "end_cancelled",
                Type = "End",
                Prompt = "Understood. Your subscription is canceled. Thank you for trying Essence of Oregon."
            },
            new DecisionNode
            {
                Id = "end_escalate",
                Type = "End",
                Prompt = "Thanks for the feedback. A specialist will review and follow up regarding your cancellation request."
            },
            new DecisionNode
            {
                Id = "end_other",
                Type = "End",
                Prompt = "Thanks for reaching out. Please contact support for assistance with non-cancellation inquiries."
            }
        };
        
        renderedNodes.Clear();
        layoutCalculated = false;
    }

    private void AddNodeAtPosition(string? parentNodeId, string? branchLabel)
    {
        var newNode = new DecisionNode
        {
            Id = $"node_{nodes.Count + 1}",
            Type = "End",
            Prompt = "Enter your prompt here"
        };
        nodes.Add(newNode);
        
        if (parentNodeId != null)
        {
            var parentNode = nodes.FirstOrDefault(n => n.Id == parentNodeId);
            if (parentNode != null)
            {
                if (parentNode.Type == "SingleChoice")
                {
                    var choice = parentNode.Choices?.FirstOrDefault(c => c.Label == branchLabel);
                    if (choice != null)
                    {
                        choice.NextNodeId = newNode.Id;
                    }
                }
                else if (parentNode.Type == "Number")
                {
                    var rule = parentNode.Rules?.FirstOrDefault(r => $"{r.Operator} {r.Value}" == branchLabel);
                    if (rule != null)
                    {
                        rule.NextNodeId = newNode.Id;
                    }
                }
            }
        }
        else if (string.IsNullOrEmpty(startNodeId))
        {
            startNodeId = newNode.Id;
        }
        
        editingNode = newNode;
        renderedNodes.Clear();
        layoutCalculated = false;
    }

    private void EditNode(DecisionNode node)
    {
        editingNode = node;
    }

    private void CloseEditModal()
    {
        editingNode = null;
        renderedNodes.Clear();
    }

    private void SaveEditedNode()
    {
        editingNode = null;
        renderedNodes.Clear();
        layoutCalculated = false;
        CalculateFlowchartLayout();
    }

    private void DeleteNode(DecisionNode node)
    {
        nodes.Remove(node);
        if (startNodeId == node.Id)
        {
            startNodeId = nodes.Any() ? nodes.First().Id : "";
        }
        
        // Remove references to this node
        foreach (var n in nodes)
        {
            if (n.Choices != null)
            {
                foreach (var choice in n.Choices)
                {
                    if (choice.NextNodeId == node.Id)
                        choice.NextNodeId = "";
                }
            }
            if (n.Rules != null)
            {
                foreach (var rule in n.Rules)
                {
                    if (rule.NextNodeId == node.Id)
                        rule.NextNodeId = "";
                }
            }
        }
        
        renderedNodes.Clear();
    }

    private void AddChoice()
    {
        if (editingNode != null)
        {
            editingNode.Choices ??= new List<Choice>();
            editingNode.Choices.Add(new Choice 
            { 
                Key = $"choice{editingNode.Choices.Count + 1}",
                Label = "New Choice",
                NextNodeId = ""
            });
        }
    }

    private void RemoveChoice(int index)
    {
        if (editingNode?.Choices != null && index < editingNode.Choices.Count)
        {
            editingNode.Choices.RemoveAt(index);
        }
    }

    private void AddRule()
    {
        if (editingNode != null)
        {
            editingNode.Rules ??= new List<Rule>();
            editingNode.Rules.Add(new Rule 
            { 
                Operator = "LessThan",
                Value = "0",
                NextNodeId = ""
            });
        }
    }

    private void RemoveRule(int index)
    {
        if (editingNode?.Rules != null && index < editingNode.Rules.Count)
        {
            editingNode.Rules.RemoveAt(index);
        }
    }

    private void NewTree()
    {
        treeId = "new-tree";
        treeVersion = "1.0.0";
        startNodeId = "";
        nodes.Clear();
        editingNode = null;
        statusMessage = "";
        renderedNodes.Clear();
    }

    private async Task LoadFile(InputFileChangeEventArgs e)
    {
        try
        {
            var file = e.File;
            if (file == null) return;

            using var stream = file.OpenReadStream(maxAllowedSize: 1024 * 1024);
            using var reader = new StreamReader(stream);
            var json = await reader.ReadToEndAsync();
            
            var result = TreeService.LoadFromJson(json);
            if (result.Success && result.Tree != null)
            {
                treeId = result.Tree.Id;
                treeVersion = result.Tree.Version;
                startNodeId = result.Tree.StartNodeId;
                nodes = result.Tree.Nodes.Values.ToList();
                editingNode = null;
                statusMessage = "Tree loaded successfully!";
                isSuccess = true;
                renderedNodes.Clear();
            }
            else
            {
                statusMessage = $"Error loading tree: {result.ErrorMessage}";
                isSuccess = false;
            }
        }
        catch (Exception ex)
        {
            statusMessage = $"Error loading file: {ex.Message}";
            isSuccess = false;
        }
    }

    private void SaveTree()
    {
        try
        {
            var tree = new DecisionTree
            {
                Id = treeId,
                Version = treeVersion,
                StartNodeId = startNodeId,
                Nodes = nodes.ToDictionary(n => n.Id, n => n)
            };

            var json = TreeService.SerializeToJson(tree);
            var result = TreeService.LoadFromJson(json);
            
            if (result.Success)
            {
                var saveResult = TreeService.SaveToFile(tree, "rules.json");
                if (saveResult.Success)
                {
                    statusMessage = "✓ Tree saved successfully to rules.json!";
                    isSuccess = true;
                }
                else
                {
                    statusMessage = $"Error saving: {saveResult.ErrorMessage}";
                    isSuccess = false;
                }
            }
            else
            {
                statusMessage = $"Validation failed: {result.ErrorMessage}";
                isSuccess = false;
            }
        }
        catch (Exception ex)
        {
            statusMessage = $"Error: {ex.Message}";
            isSuccess = false;
        }
    }

    private string GetNodeTypeBadge(string type) => type switch
    {
        "End" => "danger",
        "SingleChoice" => "primary",
        "Number" => "warning",
        _ => "secondary"
    };
}
